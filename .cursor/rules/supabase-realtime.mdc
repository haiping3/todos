---
description: Guidelines for using Supabase Realtime features
globs: ["src/**/*.ts", "src/**/*.tsx"]
alwaysApply: false
---

# Supabase Realtime Usage Guide

You're a Supabase expert in implementing realtime features. Follow these best practices for robust realtime implementations.

## Enable Realtime on Tables

```sql
-- Enable realtime for a table
alter publication supabase_realtime add table public.messages;

-- Enable with specific operations
alter publication supabase_realtime add table public.messages;
-- By default, all operations (INSERT, UPDATE, DELETE) are broadcast
```

## Client-Side Subscription Patterns

### Basic Channel Subscription

```typescript
/**
 * Basic realtime subscription
 * @author haiping.yu@zoom.us
 */

import { createClient, RealtimeChannel } from '@supabase/supabase-js';

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Subscribe to all changes on a table
const channel = supabase
  .channel('table-changes')
  .on(
    'postgres_changes',
    {
      event: '*', // 'INSERT' | 'UPDATE' | 'DELETE' | '*'
      schema: 'public',
      table: 'messages',
    },
    (payload) => {
      console.log('Change received:', payload);
    }
  )
  .subscribe();
```

### Filtered Subscriptions

```typescript
/**
 * Subscribe to specific rows using filters
 * @author haiping.yu@zoom.us
 */

// Filter by column value
const channel = supabase
  .channel('room-messages')
  .on(
    'postgres_changes',
    {
      event: 'INSERT',
      schema: 'public',
      table: 'messages',
      filter: 'room_id=eq.123', // Only messages in room 123
    },
    (payload) => {
      handleNewMessage(payload.new);
    }
  )
  .subscribe();

// Multiple filters
const userChannel = supabase
  .channel('user-notifications')
  .on(
    'postgres_changes',
    {
      event: '*',
      schema: 'public',
      table: 'notifications',
      filter: `user_id=eq.${userId}`,
    },
    handleNotification
  )
  .subscribe();
```

### React Hook Pattern

```typescript
/**
 * Custom hook for realtime subscriptions
 * @author haiping.yu@zoom.us
 */

import { useEffect, useState, useCallback } from 'react';
import { RealtimeChannel } from '@supabase/supabase-js';
import { supabase } from '@/lib/supabase';

interface Message {
  id: string;
  content: string;
  user_id: string;
  created_at: string;
}

export function useRealtimeMessages(roomId: string) {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // Fetch initial messages
    const fetchMessages = async () => {
      const { data, error } = await supabase
        .from('messages')
        .select('*')
        .eq('room_id', roomId)
        .order('created_at', { ascending: true });
      
      if (data) setMessages(data);
    };

    fetchMessages();

    // Set up realtime subscription
    const channel = supabase
      .channel(`room:${roomId}`)
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'messages',
          filter: `room_id=eq.${roomId}`,
        },
        (payload) => {
          setMessages((prev) => [...prev, payload.new as Message]);
        }
      )
      .on(
        'postgres_changes',
        {
          event: 'DELETE',
          schema: 'public',
          table: 'messages',
          filter: `room_id=eq.${roomId}`,
        },
        (payload) => {
          setMessages((prev) => 
            prev.filter((msg) => msg.id !== payload.old.id)
          );
        }
      )
      .subscribe((status) => {
        setIsConnected(status === 'SUBSCRIBED');
      });

    // Cleanup on unmount
    return () => {
      channel.unsubscribe();
    };
  }, [roomId]);

  return { messages, isConnected };
}
```

### Presence (Online Users)

```typescript
/**
 * Track online users with Presence
 * @author haiping.yu@zoom.us
 */

interface UserPresence {
  id: string;
  name: string;
  online_at: string;
}

export function usePresence(roomId: string, currentUser: UserPresence) {
  const [onlineUsers, setOnlineUsers] = useState<UserPresence[]>([]);

  useEffect(() => {
    const channel = supabase.channel(`presence:${roomId}`, {
      config: {
        presence: {
          key: currentUser.id,
        },
      },
    });

    channel
      .on('presence', { event: 'sync' }, () => {
        const state = channel.presenceState<UserPresence>();
        const users = Object.values(state).flat();
        setOnlineUsers(users);
      })
      .on('presence', { event: 'join' }, ({ key, newPresences }) => {
        console.log('User joined:', key, newPresences);
      })
      .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
        console.log('User left:', key, leftPresences);
      })
      .subscribe(async (status) => {
        if (status === 'SUBSCRIBED') {
          await channel.track({
            id: currentUser.id,
            name: currentUser.name,
            online_at: new Date().toISOString(),
          });
        }
      });

    return () => {
      channel.unsubscribe();
    };
  }, [roomId, currentUser]);

  return onlineUsers;
}
```

### Broadcast (Ephemeral Messages)

```typescript
/**
 * Broadcast for ephemeral events (typing indicators, cursor positions)
 * @author haiping.yu@zoom.us
 */

export function useTypingIndicator(roomId: string, userId: string) {
  const [typingUsers, setTypingUsers] = useState<string[]>([]);
  const channelRef = useRef<RealtimeChannel | null>(null);

  useEffect(() => {
    const channel = supabase.channel(`typing:${roomId}`);

    channel
      .on('broadcast', { event: 'typing' }, ({ payload }) => {
        if (payload.userId !== userId) {
          setTypingUsers((prev) => {
            if (payload.isTyping) {
              return [...new Set([...prev, payload.userId])];
            }
            return prev.filter((id) => id !== payload.userId);
          });
        }
      })
      .subscribe();

    channelRef.current = channel;

    return () => {
      channel.unsubscribe();
    };
  }, [roomId, userId]);

  const setTyping = useCallback((isTyping: boolean) => {
    channelRef.current?.send({
      type: 'broadcast',
      event: 'typing',
      payload: { userId, isTyping },
    });
  }, [userId]);

  return { typingUsers, setTyping };
}
```

## Best Practices

### Connection Management

```typescript
// Reuse channels when possible
const channelName = `room:${roomId}`;
let channel = supabase.getChannels().find(c => c.topic === channelName);

if (!channel) {
  channel = supabase.channel(channelName);
  // Set up subscriptions...
}
```

### Error Handling

```typescript
channel.subscribe((status, error) => {
  if (status === 'SUBSCRIBED') {
    console.log('Connected to realtime');
  } else if (status === 'CHANNEL_ERROR') {
    console.error('Realtime error:', error);
    // Implement retry logic
  } else if (status === 'TIMED_OUT') {
    console.warn('Connection timed out');
  }
});
```

### RLS with Realtime

```sql
-- Ensure RLS policies work with realtime
-- Users should only receive updates for rows they can SELECT

create policy "messages_select_room_member"
  on public.messages
  for select
  to authenticated
  using (
    exists (
      select 1 from public.room_members
      where room_members.room_id = messages.room_id
        and room_members.user_id = auth.uid()
    )
  );
```

## Performance Considerations

1. **Limit subscriptions:** Only subscribe to tables/filters you need
2. **Use filters:** More specific filters = less data transmitted
3. **Unsubscribe properly:** Always clean up subscriptions on unmount
4. **Batch updates:** Don't update state for every single change in high-frequency scenarios
5. **Consider debouncing:** For presence/broadcast, debounce rapid updates
